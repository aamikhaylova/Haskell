-- Александра Михайлова, Computer Science Center, направление Data Mining.
-- Задание 4, задача 1.

-- Дерево задано следующим описанием структуры данных:
-- data Tree a = Empty | Node (Tree a) a (Tree a)
-- Написать функцию optimalTree :: Ord a => [a] -> Tree a,
-- которая строит оптимальное двоичное дерево поиска из элементов заданного списка.
-- Двоичное дерево называется оптимальным, если на каждом его уровне с номером k содержится ровно 2k узлов,
-- кроме, возможно, последнего уровня, на котором может находиться и меньшее число узлов.

import Data.List

-- deriving Show - чтобы можно было посмотреть на результат тестов.
data Tree a = Empty | Node (Tree a) a (Tree a) deriving Show

-- Основная функция.
-- Аргумент - заданный список.
-- Результат - оптимальное двоичное дерево поиска из элементов данного списка.
-- Идея: сначала сортируем список по возрастанию (пользуясь стандартной функцией sort),
-- затем строим из него оптимальное двоичное дерево поиска с помощью вспомогательной функции optimalTreeFromSortedList.
optimalTree :: Ord a => [a] -> Tree a
optimalTree ls = (optimalTreeFromSortedList . sort) ls

-- Вспомогательная функция.
-- Отвечает за построение оптимального двоичного дерева поиска из элементов отсортированного по возрастанию списка.
-- Аргумент - отсортированный по возрастанию список.
-- Результат - оптимальное двоичное дерево поиска из элементов данного списка, построенное (рекурсивно) следующим образом:
-- вершина дерева - центральный элемент списка (после сортировки он средний по величине),
-- её левое и правое поддеревья - оптимальные двоичные деревья поиска, построенные из подсписков, составленных из
-- элементов меньше (точнее, меньше или равных) и больше (больше или равных) центрального соответственно.
optimalTreeFromSortedList :: Ord a => [a] -> Tree a
optimalTreeFromSortedList [] = Empty
optimalTreeFromSortedList ls = Node (optimalTreeFromSortedList left) node (optimalTreeFromSortedList right)
	where (left, (node:right)) = splitAt (length ls `div` 2) ls

-- Тесты.
test = (optimalTree [1, 3, 4, 2, 5], optimalTree [8, 7, 6, 5, 4, 3, 2, 1])
